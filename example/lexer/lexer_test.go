//go:build !co

// Code generated by github.com/goghcrow/go-co DO NOT EDIT.
package lexer

import (
	ʂɘʠ "github.com/goghcrow/go-co/seq"
	"reflect"
	"testing"
	"unicode"
)

func TestLexer(t *testing.T) {
	var (
		Num TokTyp = 1
		Sym TokTyp = 2

		lexWS, lexNum, lexStr StateFn
	)
	lexWS = // func(l *L) (_ Iter[Tok]) {
		// 	if l.Peek() == EOF {
		// 		return
		// 	}
		// 	if l.Consume(unicode.IsSpace) {
		// 		l.Skip()
		// 	}
		// 	YieldFrom(lexNum(l))
		// 	return
		// }
		func(l *L) (_ ʂɘʠ.Iterator[Tok]) {
			return ʂɘʠ.Start[Tok](ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
				if l.Peek() == EOF {
					return ʂɘʠ.Return[Tok]()

				}
				if l.Consume(unicode.IsSpace) {
					l.Skip()
				}
				return ʂɘʠ.Combine[Tok](
					ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
						ɪʇ := lexNum(l)
						return ʂɘʠ.While[Tok](
							ɪʇ.MoveNext,
							ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[Tok](ʌ,
									ʂɘʠ.Normal[Tok],
								)
							}))
					}),

					ʂɘʠ.Return[Tok](),
				)
			}))

		}
	lexNum = // func(l *L) (_ Iter[Tok]) {
		// 	if l.Consume(unicode.IsDigit) {
		// 		if l.Peek() == '.' {
		// 			l.Nxt()
		// 			if !l.Consume(unicode.IsDigit) {
		// 				panic("invalid num")
		// 			}
		// 			Yield(l.Tok(Num))
		// 		} else {
		// 			Yield(l.Tok(Num))
		// 		}
		// 	}
		// 	YieldFrom(lexStr(l))
		// 	return
		// }
		func(l *L) (_ ʂɘʠ.Iterator[Tok]) {
			return ʂɘʠ.Start[Tok](
				ʂɘʠ.Combine[Tok](ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
					if l.Consume(unicode.IsDigit) {
						if l.Peek() == '.' {
							l.Nxt()
							if !l.Consume(unicode.IsDigit) {
								panic("invalid num")
							}
							return ʂɘʠ.Bind[Tok](l.Tok(Num),
								ʂɘʠ.Normal[Tok],
							)
						} else {
							return ʂɘʠ.Bind[Tok](l.Tok(Num),
								ʂɘʠ.Normal[Tok],
							)
						}
					}
					return ʂɘʠ.Normal[Tok]()
				}),
					ʂɘʠ.Combine[Tok](
						ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
							ɪʇ := lexStr(l)
							return ʂɘʠ.While[Tok](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[Tok](ʌ,
										ʂɘʠ.Normal[Tok],
									)
								}))
						}),

						ʂɘʠ.Return[Tok](),
					),
				),
			)

		}
	lexStr = // func(l *L) (_ Iter[Tok]) {
		// 	if l.Consume(unicode.IsLetter) {
		// 		Yield(l.Tok(Sym))
		// 	}
		// 	YieldFrom(lexWS(l))
		// 	return
		// }
		func(l *L) (_ ʂɘʠ.Iterator[Tok]) {
			return ʂɘʠ.Start[Tok](
				ʂɘʠ.Combine[Tok](ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
					if l.Consume(unicode.IsLetter) {
						return ʂɘʠ.Bind[Tok](l.Tok(Sym),
							ʂɘʠ.Normal[Tok],
						)
					}
					return ʂɘʠ.Normal[Tok]()
				}),
					ʂɘʠ.Combine[Tok](
						ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
							ɪʇ := lexWS(l)
							return ʂɘʠ.While[Tok](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[Tok](func() ʂɘʠ.Seq[Tok] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[Tok](ʌ,
										ʂɘʠ.Normal[Tok],
									)
								}))
						}),

						ʂɘʠ.Return[Tok](),
					),
				),
			)

		}

	all := []struct {
		src    string
		expect []Tok
	}{
		{src: "", expect: nil},
		{src: "  ", expect: nil},
		{src: "3.14", expect: []Tok{{Num, "3.14"}}},
		{src: " 100 ", expect: []Tok{{Num, "100"}}},
		{src: "hello", expect: []Tok{{Sym, "hello"}}},
		{src: " world ", expect: []Tok{{Sym, "world"}}},
		{
			src: "3.14  hello   world  100",
			expect: []Tok{
				{Num, "3.14"},
				{Sym, "hello"},
				{Sym, "world"},
				{Num, "100"},
			},
		},
	}

	lexer := MkLexer(lexWS)

	for _, it := range all {
		t.Run(it.src, func(t *testing.T) {
			var got []Tok
			for ɪʇ := lexer(it.src); ɪʇ.MoveNext(); {
				tok := ɪʇ.Current()
				t.Logf("[%d](%s) ", tok.Typ, tok.Val)
				got = append(got, tok)
			}

			if !reflect.DeepEqual(it.expect, got) {
				t.Errorf("\nexpect\n%+v\n\ngot\n%+v", it.expect, got)
			}
		})
	}
}
