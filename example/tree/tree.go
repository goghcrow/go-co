//go:build !co

// Code generated by github.com/goghcrow/go-co DO NOT EDIT.
//
//go:generate go install github.com/goghcrow/go-co/cmd/cogen@main
//go:generate cogen
package tree

import (
	ʂɘʠ "github.com/goghcrow/go-co/seq"
)

type Node[V any] struct {
	Val         V
	Left, Right *Node[V]
}

type WalkMode int

const (
	PreOrder  WalkMode = 0
	InOrder            = 1
	PostOrder          = 2
)

//	func Walk[V any](n *Node[V], mode WalkMode) (_ Iter[V]) {
//		if n == nil {
//			return
//		}
//		switch mode {
//		case PreOrder:
//			Yield(n.Val)
//			YieldFrom(Walk(n.Left, mode))
//			YieldFrom(Walk(n.Right, mode))
//		case InOrder:
//			YieldFrom(Walk(n.Left, mode))
//			Yield(n.Val)
//			YieldFrom(Walk(n.Right, mode))
//		case PostOrder:
//			YieldFrom(Walk(n.Left, mode))
//			YieldFrom(Walk(n.Right, mode))
//			Yield(n.Val)
//		default:
//			panic("unknown walk mode")
//		}
//		return
//	}
func Walk[V any](n *Node[V], mode WalkMode) (_ ʂɘʠ.Iterator[V]) {
	return ʂɘʠ.Start[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
		if n == nil {
			return ʂɘʠ.Return[V]()

		}
		return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
			switch mode {
			case PreOrder:
				return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Combine[V](
						ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := Walk(n.Left, mode)
							return ʂɘʠ.While[V](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[V](ʌ,
										ʂɘʠ.Normal[V],
									)
								}))
						}),

						ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := Walk(n.Right, mode)
							return ʂɘʠ.While[V](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[V](ʌ,
										ʂɘʠ.Normal[V],
									)
								}))
						}),
					)
				})
			case InOrder:
				return ʂɘʠ.Combine[V](
					ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						ɪʇ := Walk(n.Left, mode)
						return ʂɘʠ.While[V](
							ɪʇ.MoveNext,
							ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ,
									ʂɘʠ.Normal[V],
								)
							}))
					}),
					ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
							return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ɪʇ := Walk(n.Right, mode)
								return ʂɘʠ.While[V](
									ɪʇ.MoveNext,
									ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
										ʌ := ɪʇ.Current()
										return ʂɘʠ.Bind[V](ʌ,
											ʂɘʠ.Normal[V],
										)
									}))
							})
						})
					}))
			case PostOrder:
				return ʂɘʠ.Combine[V](
					ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						ɪʇ := Walk(n.Left, mode)
						return ʂɘʠ.While[V](
							ɪʇ.MoveNext,
							ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ,
									ʂɘʠ.Normal[V],
								)
							}))
					}),

					ʂɘʠ.Combine[V](
						ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := Walk(n.Right, mode)
							return ʂɘʠ.While[V](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[V](ʌ,
										ʂɘʠ.Normal[V],
									)
								}))
						}),
						ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							return ʂɘʠ.Bind[V](n.Val,
								ʂɘʠ.Normal[V],
							)
						})),
				)
			default:

				panic("unknown walk mode")
			}
		}),
			ʂɘʠ.Return[V](),
		)
	}))

}

// Match the same iterating path
func Match[V comparable](rootA, rootB *Node[V], mode WalkMode) bool {
	if rootA == rootB {
		return true
	}
	if rootA == nil || rootB == nil {
		return false
	}

	a, b := Walk(rootA, mode), Walk(rootB, mode)

	for {
		na, nb := a.MoveNext(), b.MoveNext()
		if na != nb {
			return false
		}
		if !na {
			return true
		}
		if a.Current() != b.Current() {
			return false
		}
	}
}
