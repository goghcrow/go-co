//go:build !co

// Code generated by github.com/goghcrow/go-co DO NOT EDIT.
package src

import (
	ʂɘʠ "github.com/goghcrow/go-co/seq"
	"testing"
)

func TestForRange(t *testing.T) {
	yield123 := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](
			ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](3,
						ʂɘʠ.Return[int],
					)
				})
			}),
		)

	}

	var xs []int
	for ɪʇ := yield123(); ɪʇ.MoveNext(); {
		v := ɪʇ.Current()
		xs = append(xs, v)
	}

	assertEqual(t, xs, []int{1, 2, 3})

	var ys []int
	iter := yield123()
	for iter.MoveNext() {
		ys = append(ys, iter.Current())
		ys = append(ys, iter.Current())
	}
	assertEqual(t, ys, []int{1, 1, 2, 2, 3, 3})
}

func Test123(t *testing.T) {
	yield123 := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](
			ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](3,
						ʂɘʠ.Return[int],
					)
				})
			}),
		)

	}
	xs := iter2slice(yield123())
	assertEqual(t, xs, []int{1, 2, 3})

	{
		assertEqual(t, iter2slice(func() ʂɘʠ.Iterator[int] {
			return ʂɘʠ.Start[int](
				ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](3,
							ʂɘʠ.Return[int],
						)
					})
				}),
			)

		}()), []int{1, 2, 3})
	}
}

func TestYieldFrom(t *testing.T) {
	var (
		from = func() ʂɘʠ.Iterator[int] {
			return ʂɘʠ.Start[int](
				ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](2,
						ʂɘʠ.Return[int],
					)
				}),
			)

		}
		gen = func() ʂɘʠ.Iterator[int] {
			return ʂɘʠ.Start[int](
				ʂɘʠ.Combine[int](
					ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						ɪʇ := from()
						return ʂɘʠ.While[int](
							ɪʇ.MoveNext,
							ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[int](ʌ,
									ʂɘʠ.Normal[int],
								)
							}))
					}),

					ʂɘʠ.Bind[int](3,
						ʂɘʠ.Return[int],
					),
				),
			)

		}
	)
	xs := iter2slice(gen())
	assertEqual(t, xs, []int{1, 2, 3})
}

func TestYieldABC(t *testing.T) {
	f := func() {}
	g := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](
			ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {

				f()
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if false {
						return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {

							f()
							return ʂɘʠ.Normal[int]()
						})
					} else {
						return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {

							i := 0
							return ʂɘʠ.For[int](func() bool {
								return i < 3
							}, func() {
								i++
							}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								return ʂɘʠ.Bind[int](i, func() ʂɘʠ.Seq[int] {

									f()
									return ʂɘʠ.Normal[int]()
								})
							}))
						})
					}
				}),
					ʂɘʠ.Combine[int](
						ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ɪʇ := func() ʂɘʠ.Iterator[int] {
								return ʂɘʠ.Start[int](
									ʂɘʠ.Bind[int](1,
										ʂɘʠ.Return[int],
									),
								)

							}()
							return ʂɘʠ.While[int](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[int](ʌ,
										ʂɘʠ.Normal[int],
									)
								}))
						}),

						ʂɘʠ.Return[int](),
					),
				)
			}),
		)

	}
	xs := iter2slice(g())
	assertEqual(t, xs, []int{1, 0, 1, 2, 1})
}

func TestYieldFunc(t *testing.T) {
	gen := func() ʂɘʠ.Iterator[func() string] {
		return ʂɘʠ.Start[func() string](ʂɘʠ.Delay[func() string](func() ʂɘʠ.Seq[func() string] {
			return ʂɘʠ.Bind[func() string](func() string { return "hello" }, func() ʂɘʠ.Seq[func() string] {
				return ʂɘʠ.Bind[func() string](func() string { return "world" },
					ʂɘʠ.Return[func() string],
				)
			})
		}))

	}
	var xs []string
	for ɪʇ := gen(); ɪʇ.MoveNext(); {
		f := ɪʇ.Current()
		xs = append(xs, f())
	}

	assertEqual(t, xs, []string{"hello", "world"})
}

func TestRecursive1(t *testing.T) {
	recGen := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			var rec func(int) ʂɘʠ.Iterator[int]
			rec = func(n int) (_ ʂɘʠ.Iterator[int]) {
				return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if n == 0 {
						return ʂɘʠ.Return[int]()

					}
					return ʂɘʠ.Bind[int](0, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Combine[int](
							ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ɪʇ := rec(n - 1)
								return ʂɘʠ.While[int](
									ɪʇ.MoveNext,
									ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
										ʌ := ɪʇ.Current()
										return ʂɘʠ.Bind[int](ʌ,
											ʂɘʠ.Normal[int],
										)
									}))
							}),

							ʂɘʠ.Return[int](),
						)
					})
				}))

			}
			return ʂɘʠ.Combine[int](
				ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					ɪʇ := rec(5)
					return ʂɘʠ.While[int](
						ɪʇ.MoveNext,
						ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[int](ʌ,
								ʂɘʠ.Normal[int],
							)
						}))
				}),

				ʂɘʠ.Return[int](),
			)
		}))

	}

	xs := iter2slice(recGen())
	assertEqual(t, xs, []int{0, 0, 0, 0, 0})
}

func TestRecursive2(t *testing.T) {
	var from func(a int) ʂɘʠ.Iterator[int]
	from = func(a int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](1+a, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if a <= 3 {
						return ʂɘʠ.Combine[int](
							ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ɪʇ := from(a + 3)
								return ʂɘʠ.While[int](
									ɪʇ.MoveNext,
									ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
										ʌ := ɪʇ.Current()
										return ʂɘʠ.Bind[int](ʌ,
											ʂɘʠ.Normal[int],
										)
									}))
							}),

							ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ɪʇ := from(a + 6)
								return ʂɘʠ.While[int](
									ɪʇ.MoveNext,
									ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
										ʌ := ɪʇ.Current()
										return ʂɘʠ.Bind[int](ʌ,
											ʂɘʠ.Normal[int],
										)
									}))
							}),
						)
					}
					return ʂɘʠ.Normal[int]()
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](2+a,
						ʂɘʠ.Return[int],
					)
				}))
			})
		}))

	}
	gen := func() (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](
			ʂɘʠ.Combine[int](
				ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					ɪʇ := from(0)
					return ʂɘʠ.While[int](
						ɪʇ.MoveNext,
						ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[int](ʌ,
								ʂɘʠ.Normal[int],
							)
						}))
				}),

				ʂɘʠ.Return[int](),
			),
		)

	}
	xs := iter2slice(gen())
	assertEqual(t, xs, []int{1, 4, 7, 8, 10, 11, 5, 7, 8, 2})
}

func TestDeepRecursive(t *testing.T) {
	from := func(i int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](i,
				ʂɘʠ.Return[int],
			)
		}))

	}
	var gen func(int) ʂɘʠ.Iterator[int]
	gen = func(i int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](
			ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				if i < 50000 {
					return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						ɪʇ := gen(i + 1)
						return ʂɘʠ.While[int](
							ɪʇ.MoveNext,
							ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[int](ʌ,
									ʂɘʠ.Normal[int],
								)
							}))
					})
				} else {
					return ʂɘʠ.Bind[int](i, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ɪʇ := from(i + 1)
							return ʂɘʠ.While[int](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[int](ʌ,
										ʂɘʠ.Normal[int],
									)
								}))
						})
					})
				}
			}),
				ʂɘʠ.Return[int](),
			),
		)

	}
	xs := iter2slice(gen(0))
	assertEqual(t, xs, []int{50000, 50001})
}

func TestYieldFromSameGen(t *testing.T) {
	var gen func(int) ʂɘʠ.Iterator[int]
	gen = func(a int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](1+a, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if a < 1 {
						return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ɪʇ := gen(a + 1)
							return ʂɘʠ.While[int](
								ɪʇ.MoveNext,
								ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[int](ʌ,
										ʂɘʠ.Normal[int],
									)
								}))
						})
					}
					return ʂɘʠ.Normal[int]()
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](3+a,
						ʂɘʠ.Return[int],
					)
				}))
			})
		}))

	}
	bar := func(gen ʂɘʠ.Iterator[int]) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](
			ʂɘʠ.Combine[int](
				ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					ɪʇ := gen
					return ʂɘʠ.While[int](
						ɪʇ.MoveNext,
						ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[int](ʌ,
								ʂɘʠ.Normal[int],
							)
						}))
				}),

				ʂɘʠ.Return[int](),
			),
		)

	}

	assertEqual(t, iter2slice(bar(gen(0))), []int{1, 2, 4, 3})

	g := gen(0)
	a, b := bar(g), bar(g)

	var xs, ys []int
	for {
		if a.MoveNext() {
			xs = append(xs, a.Current())
		} else {
			break
		}
		if b.MoveNext() {
			ys = append(ys, b.Current())
		} else {
			break
		}
	}
	assertEqual(t, xs, []int{1, 4})
	assertEqual(t, ys, []int{2, 3})
}
