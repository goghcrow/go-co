//go:build !co
// +build !co

// Code generated by github.com/goghcrow/go-co DO NOT EDIT.
package src

import (
	"testing"

	. "github.com/goghcrow/go-co"
	ʂɘʠ "github.com/goghcrow/go-co/seq"
)

type Node[V any] struct {
	Val         V
	Left, Right *Node[V]
}

type WalkMode int

const (
	PreOrder  WalkMode = 0
	InOrder            = 1
	PostOrder          = 2
)

func Walk[V any](n *Node[V], mode WalkMode) (_ ʂɘʠ.Iterator[V]) {
	return ʂɘʠ.Start[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
		if n == nil {
			return ʂɘʠ.Return[V]()

		}
		return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
			if mode == PreOrder {
				return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := Walk(n.Left, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := Walk(n.Right, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					}))
				})
			} else if mode == InOrder {
				return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						ɪʇ := Walk(n.Left, mode)
						return ʂɘʠ.While[V](func() bool {
							return ɪʇ.MoveNext()
						}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
								return ʂɘʠ.Normal[V]()
							})
						}))
					})
				}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := Walk(n.Right, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					})
				}))
			} else if mode == PostOrder {
				return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						ɪʇ := Walk(n.Left, mode)
						return ʂɘʠ.While[V](func() bool {
							return ɪʇ.MoveNext()
						}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
								return ʂɘʠ.Normal[V]()
							})
						}))
					})
				}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := Walk(n.Right, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
							return ʂɘʠ.Normal[V]()
						})
					}))
				}))
			} else {

				panic("unknown walk mode")
			}
		}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
			return ʂɘʠ.Return[V]()
		}))
	}))

}

func WalkSwitch[V any](n *Node[V], mode WalkMode) (_ ʂɘʠ.Iterator[V]) {
	return ʂɘʠ.Start[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
		if n == nil {
			return ʂɘʠ.Return[V]()

		}
		return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
			switch mode {
			case PreOrder:
				return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := WalkSwitch(n.Left, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := WalkSwitch(n.Right, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					}))
				})
			case InOrder:
				return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						ɪʇ := WalkSwitch(n.Left, mode)
						return ʂɘʠ.While[V](func() bool {
							return ɪʇ.MoveNext()
						}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
								return ʂɘʠ.Normal[V]()
							})
						}))
					})
				}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := WalkSwitch(n.Right, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					})
				}))
			case PostOrder:
				return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						ɪʇ := WalkSwitch(n.Left, mode)
						return ʂɘʠ.While[V](func() bool {
							return ɪʇ.MoveNext()
						}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
								return ʂɘʠ.Normal[V]()
							})
						}))
					})
				}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
					return ʂɘʠ.Combine[V](ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
							ɪʇ := WalkSwitch(n.Right, mode)
							return ʂɘʠ.While[V](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[V](ʌ, func() ʂɘʠ.Seq[V] {
									return ʂɘʠ.Normal[V]()
								})
							}))
						})
					}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
						return ʂɘʠ.Bind[V](n.Val, func() ʂɘʠ.Seq[V] {
							return ʂɘʠ.Normal[V]()
						})
					}))
				}))
			default:

				panic("unknown walk mode")
			}
		}), ʂɘʠ.Delay[V](func() ʂɘʠ.Seq[V] {
			return ʂɘʠ.Return[V]()
		}))
	}))

}

// Match the same iterating path
func Match[V comparable](rootA, rootB *Node[V], mode WalkMode, Walk func(*Node[V], WalkMode) ʂɘʠ.Iterator[V]) bool {
	if rootA == rootB {
		return true
	}
	if rootA == nil || rootB == nil {
		return false
	}

	a, b := Walk(rootA, mode), Walk(rootB, mode)

	for {
		na, nb := a.MoveNext(), b.MoveNext()
		if na != nb {
			return false
		}
		if !na {
			return true
		}
		if a.Current() != b.Current() {
			return false
		}
	}
}

func TestTreeWalker(t *testing.T) {

	root := &Node[int]{
		Val: 5,
		Left: &Node[int]{
			Val: 3,
			Left: &Node[int]{
				Val: 1,
			},
			Right: &Node[int]{
				Val: 4,
			},
		},
		Right: &Node[int]{
			Val: 7,
			Right: &Node[int]{
				Val: 9,
				Left: &Node[int]{
					Val: 8,
				},
			},
		},
	}

	{
		preorder := iter2slice(Walk(root, PreOrder))
		assertEqual(t, preorder, []int{5, 3, 1, 4, 7, 9, 8})

		inorder := iter2slice(Walk(root, InOrder))
		assertEqual(t, inorder, []int{1, 3, 4, 5, 7, 8, 9})

		postorder := iter2slice(Walk(root, PostOrder))
		assertEqual(t, postorder, []int{1, 4, 3, 8, 9, 7, 5})
	}
	{
		preorder := iter2slice(WalkSwitch(root, PreOrder))
		assertEqual(t, preorder, []int{5, 3, 1, 4, 7, 9, 8})

		inorder := iter2slice(WalkSwitch(root, InOrder))
		assertEqual(t, inorder, []int{1, 3, 4, 5, 7, 8, 9})

		postorder := iter2slice(WalkSwitch(root, PostOrder))
		assertEqual(t, postorder, []int{1, 4, 3, 8, 9, 7, 5})
	}
}

func TestTreeMatcher(t *testing.T) {

	rootA := &Node[int]{
		Val: 1,
		Left: &Node[int]{
			Val: 2,
		},
		Right: &Node[int]{
			Val: 3,
		},
	}

	rootB := &Node[int]{
		Val: 3,
		Left: &Node[int]{
			Val: 1,
			Left: &Node[int]{
				Val: 2,
			},
		},
	}

	{
		assertEqual(t, Match(rootA, rootB, PreOrder, Walk[int]), false)
		assertEqual(t, Match(rootA, rootB, InOrder, Walk[int]), true)
		assertEqual(t, Match(rootA, rootB, PostOrder, Walk[int]), false)
	}
	{
		assertEqual(t, Match(rootA, rootB, PreOrder, WalkSwitch[int]), false)
		assertEqual(t, Match(rootA, rootB, InOrder, WalkSwitch[int]), true)
		assertEqual(t, Match(rootA, rootB, PostOrder, WalkSwitch[int]), false)
	}
}
