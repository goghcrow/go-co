// Code generated by github.com/goghcrow/go-co DO NOT EDIT.
package src

import (
	"sort"
	"testing"

	. "github.com/goghcrow/go-co"
	ʂɘʠ "github.com/goghcrow/go-co/seq"
)

func TestRangeString(t *testing.T) {
	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewStringIter("")
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int(nil))
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewStringIter("hello")
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{1, 1, 1, 1, 1})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewStringIter("hello")
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[int](k, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{0, 1, 2, 3, 4})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewStringIter("hello")
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[int](k, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{0, 1, 2, 3, 4})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[rune]) {
			return ʂɘʠ.Start[rune](ʂɘʠ.Delay[rune](func() ʂɘʠ.Seq[rune] {
				ɪʇ := ʂɘʠ.NewStringIter("hello")
				return ʂɘʠ.Combine[rune](ʂɘʠ.Delay[rune](func() ʂɘʠ.Seq[rune] {
					return ʂɘʠ.While[rune](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[rune](func() ʂɘʠ.Seq[rune] {
						v := ɪʇ.Current().Val
						return ʂɘʠ.Bind[rune](v, func() ʂɘʠ.Seq[rune] {
							return ʂɘʠ.Normal[rune]()
						})
					}))
				}), ʂɘʠ.Delay[rune](func() ʂɘʠ.Seq[rune] {
					return ʂɘʠ.Return[rune]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []rune("hello"))
	}
}

func TestRangeSlice(t *testing.T) {
	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				var xs []int
				ɪʇ := ʂɘʠ.NewSliceIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int(nil))
	}

	xs := []int{1, 2, 3, 4, 5}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{1, 1, 1, 1, 1})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[int](k, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{0, 1, 2, 3, 4})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[int](k, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{0, 1, 2, 3, 4})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						v := ɪʇ.Current().Val
						return ʂɘʠ.Bind[int](v, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{1, 2, 3, 4, 5})
	}
}

func TestRangeArray(t *testing.T) {
	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				var xs [0]int
				ɪʇ := ʂɘʠ.NewSliceIter(xs[:])
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int(nil))
	}

	xs := [5]int{1, 2, 3, 4, 5}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs[:])
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{1, 1, 1, 1, 1})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs[:])
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[int](k, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{0, 1, 2, 3, 4})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs[:])
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[int](k, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{0, 1, 2, 3, 4})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewSliceIter(xs[:])
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						v := ɪʇ.Current().Val
						return ʂɘʠ.Bind[int](v, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{1, 2, 3, 4, 5})
	}
}

func TestRangeMap(t *testing.T) {
	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				var xs map[string]int
				ɪʇ := ʂɘʠ.NewMapIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int(nil))
	}

	xs := map[string]int{
		"1": 1, "2": 2, "3": 3, "4": 4, "5": 5,
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewMapIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{1, 1, 1, 1, 1})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[string]) {
			return ʂɘʠ.Start[string](ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
				ɪʇ := ʂɘʠ.NewMapIter(xs)
				return ʂɘʠ.Combine[string](ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
					return ʂɘʠ.While[string](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[string](k, func() ʂɘʠ.Seq[string] {
							return ʂɘʠ.Normal[string]()
						})
					}))
				}), ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
					return ʂɘʠ.Return[string]()
				}))
			}))

		}

		s := iter2slice(g())
		sort.Strings(s)
		assertEqual(t, s, []string{"1", "2", "3", "4", "5"})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[string]) {
			return ʂɘʠ.Start[string](ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
				ɪʇ := ʂɘʠ.NewMapIter(xs)
				return ʂɘʠ.Combine[string](ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
					return ʂɘʠ.While[string](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
						k := ɪʇ.Current().Key
						return ʂɘʠ.Bind[string](k, func() ʂɘʠ.Seq[string] {
							return ʂɘʠ.Normal[string]()
						})
					}))
				}), ʂɘʠ.Delay[string](func() ʂɘʠ.Seq[string] {
					return ʂɘʠ.Return[string]()
				}))
			}))

		}

		s := iter2slice(g())
		sort.Strings(s)
		assertEqual(t, s, []string{"1", "2", "3", "4", "5"})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewMapIter(xs)
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						v := ɪʇ.Current().Val
						return ʂɘʠ.Bind[int](v, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}

		s := iter2slice(g())
		sort.Ints(s)
		assertEqual(t, s, []int{1, 2, 3, 4, 5})
	}
}

func TestRangeChan(t *testing.T) {
	mkCh := func(len int) <-chan int {
		xs := make(chan int, len)
		for i := 0; i < len; i++ {
			xs <- i
		}
		close(xs)
		return xs
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewChanIter(mkCh(0))
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int(nil))
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewChanIter(mkCh(5))
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{1, 1, 1, 1, 1})
	}

	{
		g := func() (_ ʂɘʠ.Iterator[int]) {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				ɪʇ := ʂɘʠ.NewChanIter(mkCh(5))
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						v := ɪʇ.Current().Key
						return ʂɘʠ.Bind[int](v, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Return[int]()
				}))
			}))

		}
		assertEqual(t, iter2slice(g()), []int{0, 1, 2, 3, 4})
	}
}
