// Code generated by github.com/goghcrow/go-co DO NOT EDIT.
package src

import (
	"reflect"
	"testing"

	. "github.com/goghcrow/go-co"
	ʂɘʠ "github.com/goghcrow/go-co/seq"
)

func TestForRange(t *testing.T) {
	yield123 := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](3, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Return[int]()
					})
				})
			})
		}))

	}

	var xs []int
	{
		ɪʇ := yield123()
		for ɪʇ.MoveNext() {
			v := ɪʇ.Current()
			xs = append(xs, v)
		}
	}

	assertEqual(t, xs, []int{1, 2, 3})

	var ys []int
	iter := yield123()
	for iter.MoveNext() {
		ys = append(ys, iter.Current())
		ys = append(ys, iter.Current())
	}
	assertEqual(t, ys, []int{1, 1, 2, 2, 3, 3})
}

func Test123(t *testing.T) {
	yield123 := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](3, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Return[int]()
					})
				})
			})
		}))

	}
	xs := iter2slice(yield123())
	assertEqual(t, xs, []int{1, 2, 3})

	{
		assertEqual(t, iter2slice(func() ʂɘʠ.Iterator[int] {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](3, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Return[int]()
						})
					})
				})
			}))

		}()), []int{1, 2, 3})
	}
}

func TestYieldFrom(t *testing.T) {
	var (
		from = func() ʂɘʠ.Iterator[int] {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Return[int]()
					})
				})
			}))

		}
		gen = func() ʂɘʠ.Iterator[int] {
			return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						ɪʇ := from()
						return ʂɘʠ.While[int](func() bool {
							return ɪʇ.MoveNext()
						}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
								return ʂɘʠ.Normal[int]()
							})
						}))
					})
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](3, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Return[int]()
					})
				}))
			}))

		}
	)
	xs := iter2slice(gen())
	assertEqual(t, xs, []int{1, 2, 3})
}

func TestYieldABC(t *testing.T) {
	f := func() {}
	g := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {

				f()
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if false {
						return ʂɘʠ.Bind[int](2, func() ʂɘʠ.Seq[int] {

							f()
							return ʂɘʠ.Normal[int]()
						})
					} else {
						return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {

							i := 0
							return ʂɘʠ.For[int](func() bool {
								return i < 3
							}, func() {
								i++
							}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								return ʂɘʠ.Bind[int](i, func() ʂɘʠ.Seq[int] {

									f()
									return ʂɘʠ.Normal[int]()
								})
							}))
						})
					}
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ɪʇ := func() ʂɘʠ.Iterator[int] {
								return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
									return ʂɘʠ.Bind[int](1, func() ʂɘʠ.Seq[int] {
										return ʂɘʠ.Return[int]()
									})
								}))

							}()
							return ʂɘʠ.While[int](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
									return ʂɘʠ.Normal[int]()
								})
							}))
						})
					}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Return[int]()
					}))
				}))
			})
		}))

	}
	xs := iter2slice(g())
	assertEqual(t, xs, []int{1, 0, 1, 2, 1})
}

func TestYieldFunc(t *testing.T) {
	gen := func() ʂɘʠ.Iterator[func() string] {
		return ʂɘʠ.Start[func() string](ʂɘʠ.Delay[func() string](func() ʂɘʠ.Seq[func() string] {
			return ʂɘʠ.Bind[func() string](func() string { return "hello" }, func() ʂɘʠ.Seq[func() string] {
				return ʂɘʠ.Bind[func() string](func() string { return "world" }, func() ʂɘʠ.Seq[func() string] {
					return ʂɘʠ.Return[func() string]()
				})
			})
		}))

	}
	var xs []string
	{
		ɪʇ := gen()
		for ɪʇ.MoveNext() {
			f := ɪʇ.Current()
			xs = append(xs, f())
		}
	}

	assertEqual(t, xs, []string{"hello", "world"})
}

func TestRecursive1(t *testing.T) {
	recGen := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			var rec func(int) ʂɘʠ.Iterator[int]
			rec = func(n int) (_ ʂɘʠ.Iterator[int]) {
				return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if n == 0 {
						return ʂɘʠ.Return[int]()

					}
					return ʂɘʠ.Bind[int](0, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ɪʇ := rec(n - 1)
								return ʂɘʠ.While[int](func() bool {
									return ɪʇ.MoveNext()
								}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
										return ʂɘʠ.Normal[int]()
									})
								}))
							})
						}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Return[int]()
						}))
					})
				}))

			}
			return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					ɪʇ := rec(5)
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						ʌ := ɪʇ.Current()
						return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				})
			}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Return[int]()
			}))
		}))

	}

	xs := iter2slice(recGen())
	assertEqual(t, xs, []int{0, 0, 0, 0, 0})
}

func TestRecursive2(t *testing.T) {
	var from func(a int) ʂɘʠ.Iterator[int]
	from = func(a int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](1+a, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if a <= 3 {
						return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ɪʇ := from(a + 3)
								return ʂɘʠ.While[int](func() bool {
									return ɪʇ.MoveNext()
								}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
										return ʂɘʠ.Normal[int]()
									})
								}))
							})
						}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ɪʇ := from(a + 6)
								return ʂɘʠ.While[int](func() bool {
									return ɪʇ.MoveNext()
								}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
									ʌ := ɪʇ.Current()
									return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
										return ʂɘʠ.Normal[int]()
									})
								}))
							})
						}))
					}
					return ʂɘʠ.Normal[int]()
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](2+a, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Return[int]()
					})
				}))
			})
		}))

	}
	gen := func() (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					ɪʇ := from(0)
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						ʌ := ɪʇ.Current()
						return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				})
			}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Return[int]()
			}))
		}))

	}
	xs := iter2slice(gen())
	assertEqual(t, xs, []int{1, 4, 7, 8, 10, 11, 5, 7, 8, 2})
}

func TestDeepRecursive(t *testing.T) {
	from := func(i int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](i, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Return[int]()
			})
		}))

	}
	var gen func(int) ʂɘʠ.Iterator[int]
	gen = func(i int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				if i < 50000 {
					return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						ɪʇ := gen(i + 1)
						return ʂɘʠ.While[int](func() bool {
							return ɪʇ.MoveNext()
						}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ʌ := ɪʇ.Current()
							return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
								return ʂɘʠ.Normal[int]()
							})
						}))
					})
				} else {
					return ʂɘʠ.Bind[int](i, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ɪʇ := from(i + 1)
							return ʂɘʠ.While[int](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
									return ʂɘʠ.Normal[int]()
								})
							}))
						})
					})
				}
			}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Return[int]()
			}))
		}))

	}
	xs := iter2slice(gen(0))
	assertEqual(t, xs, []int{50000, 50001})
}

func TestXRange(t *testing.T) {
	xrange := func(start, end, step int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					i := start
					return ʂɘʠ.For[int](func() bool {
						return i <= end
					}, func() {
						i += step
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Bind[int](i, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				})
			}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Return[int]()
			}))
		}))

	}
	var xs []int
	{
		ɪʇ := xrange(10, 20, 2)
		for ɪʇ.MoveNext() {
			i := ɪʇ.Current()
			xs = append(xs, i)
		}
	}

	assertEqual(t, xs, []int{10, 12, 14, 16, 18, 20})
}

func TestYieldFromSameGen(t *testing.T) {
	var gen func(int) ʂɘʠ.Iterator[int]
	gen = func(a int) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Bind[int](1+a, func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					if a < 1 {
						return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
							ɪʇ := gen(a + 1)
							return ʂɘʠ.While[int](func() bool {
								return ɪʇ.MoveNext()
							}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
								ʌ := ɪʇ.Current()
								return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
									return ʂɘʠ.Normal[int]()
								})
							}))
						})
					}
					return ʂɘʠ.Normal[int]()
				}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					return ʂɘʠ.Bind[int](3+a, func() ʂɘʠ.Seq[int] {
						return ʂɘʠ.Return[int]()
					})
				}))
			})
		}))

	}
	bar := func(gen ʂɘʠ.Iterator[int]) (_ ʂɘʠ.Iterator[int]) {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			return ʂɘʠ.Combine[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
					ɪʇ := gen
					return ʂɘʠ.While[int](func() bool {
						return ɪʇ.MoveNext()
					}, ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
						ʌ := ɪʇ.Current()
						return ʂɘʠ.Bind[int](ʌ, func() ʂɘʠ.Seq[int] {
							return ʂɘʠ.Normal[int]()
						})
					}))
				})
			}), ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Return[int]()
			}))
		}))

	}

	assertEqual(t, iter2slice(bar(gen(0))), []int{1, 2, 4, 3})

	g := gen(0)
	a, b := bar(g), bar(g)

	var xs, ys []int
	for {
		if a.MoveNext() {
			xs = append(xs, a.Current())
		} else {
			break
		}
		if b.MoveNext() {
			ys = append(ys, b.Current())
		} else {
			break
		}
	}
	assertEqual(t, xs, []int{1, 4})
	assertEqual(t, ys, []int{2, 3})
}

func TestFib(t *testing.T) {
	fib := func() ʂɘʠ.Iterator[int] {
		return ʂɘʠ.Start[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
			a, b := 1, 1
			return ʂɘʠ.Loop[int](ʂɘʠ.Delay[int](func() ʂɘʠ.Seq[int] {
				return ʂɘʠ.Bind[int](b, func() ʂɘʠ.Seq[int] {

					a, b = b, a+b
					return ʂɘʠ.Normal[int]()
				})
			}))
		}))

	}
	{
		ɪʇ := fib()
		for ɪʇ.MoveNext() {
			n := ɪʇ.Current()
			if n > 1000 {
				assertEqual(t, n, 1597)
				break
			}
		}
	}

}

func iter2slice[V any](g ʂɘʠ.Iterator[V]) []V {
	var s []V
	{
		ɪʇ := g
		for ɪʇ.MoveNext() {
			i := ɪʇ.Current()
			s = append(s, i)
		}
	}

	return s
}
func assertEqual(t *testing.T, a, b interface{}) {
	if !reflect.DeepEqual(a, b) {
		t.Logf("expect %+v got %+v", b, a)
		t.FailNow()
	}
}
